# Git Operations: Platform-Backend

> **Policy module**: Activated via `## Selected Policies` in project `.claude/CLAUDE.md`.
> Advanced git workflows for multi-branch, multi-service repositories.
> **Includes all rules from `git/standard.md`** — you do not need to list both.

Standards derived from real-world experience across multi-branch, multi-service repositories. Project-level `.claude/CLAUDE.md` files may add project-specific conventions (e.g., ticket prefixes).

---

## Base Rules (from git/standard.md)

- **No Co-Authored-By**: Do NOT include `Co-Authored-By` lines in commit messages
- **No AI attribution footers**: Do NOT include "Generated with Claude Code", "Generated by AI", or similar attribution lines in commit messages, PR/MR descriptions, comments, or any other generated content
- Use conventional commit prefixes (feat, fix, chore, docs, refactor, test)
- Use imperative mood in commit summaries ("Add feature" not "Added feature")
- Keep commits focused and atomic - one logical change per commit
- Remote connectivity check before push/pull/fetch: `timeout 5 git ls-remote --exit-code origin HEAD`
- **NEVER** force-push to `master`, `main`, or `release/*` branches

---

## Cherry-Pick & Cross-Branch Feature Propagation

When propagating features across branches (e.g., from a development/nightly branch to release/master), follow these patterns:

### Named Pick Branches
Create a dedicated feature branch for each cross-branch pick:
```
feature/<TICKET>-from-<SOURCE-BRANCH>
```

**Examples**:
- `feature/PROJ-123-scheduling-from-release` (picking from release to master)
- `feature/PROJ-456-template-updates-from-nightly` (picking from nightly to master)

**Why**: Named branches provide a clear audit trail, allow code review via MR/PR, and prevent accidental inclusion of unwanted changes.

### Commit Message Format for Picks
```
[TICKET] Pick <description> from <source-branch>
```
**Examples**:
- `[PROJ-123] Pick independent scheduling improvements from release/2026.03`
- `[PROJ-456, PROJ-789] Pick per-schedule assets and legacy migration from nightly`

### Hand-Merge Pattern
When cherry-pick conflicts are too complex for automatic resolution, manually recreate the changes:

1. Read the source commit(s) to understand the intent
2. Manually implement the same changes in the target branch
3. Annotate the commit with `(hand-merged from <source>)`

```
PROJ-123: Fix missing template support from endpoint (hand-merged from nightly)
```

**When to hand-merge vs resolve conflicts**:
- **Resolve conflicts**: When conflicts are simple (import ordering, adjacent-line edits)
- **Hand-merge**: When the source and target have diverged significantly, or when cherry-pick touches code that has been refactored on the target branch

### Post-Pick Formatting
After cherry-picking or hand-merging multi-file changes, formatting may drift:
- Create a **separate commit** for formatting fixes: `Fix formatting for <feature> files`
- Keeps feature logic separate from cosmetic changes
- Makes code review cleaner (reviewers can skip the formatting commit)

### What NOT to Do
- **Never raw `git cherry-pick` onto shared branches** without a named branch + MR (exception: Cherry-Pick Merge Hybrid on unstable dev branches — see below)
- **Never force cherry-pick through conflicts** (`git cherry-pick --theirs`) - hand-merge instead
- **Never cherry-pick migrations** from other branches - always create new merge migrations

---

## Cherry-Pick Merge Hybrid (Unstable Development Branches)

On unstable development branches (e.g., nightly), MR merge rules may require passing pipelines — but tests are frequently unstable due to ongoing development work. This blocks merging even when the code itself is correct and reviewed.

The cherry-pick merge hybrid preserves the value of MRs (CI runs, code review, pipeline artifacts) while bypassing the merge gate that would otherwise block on unrelated test failures.

> **Scope restriction**: This workflow is ONLY for unstable development branches where test instability is a known, ongoing condition. **Release and master branches must use normal MR merge flow** — no exceptions.

### Workflow

1. **Create feature branch and open MR** targeting the dev branch (e.g., nightly)
2. **Iterate** — let CI run, get code review, push fixes as needed
3. **When ready to land**: Rebase-squash the feature branch down to a single commit
   ```bash
   # On the feature branch
   git rebase -i origin/nightly   # squash all commits into one
   git push --force-with-lease    # update the feature branch (force-push is safe here — it's your branch)
   ```
4. **Cherry-pick onto the dev branch**:
   ```bash
   git checkout nightly
   git pull origin nightly
   git cherry-pick <squashed-commit-hash>
   git push origin nightly
   ```
5. **Clean up**: Delete the feature branch. The MR will auto-close (GitLab) or can be closed manually with a note referencing the cherry-picked commit

### Why This Works

| Concern | How it's addressed |
|---------|-------------------|
| Code review | MR provides the review artifact — comments, approvals, and CI results are preserved even after the MR is closed |
| CI/pipeline checks | Pipeline runs on the MR give visibility into test results, even if unrelated failures block merge |
| Clean history | Squashing before cherry-pick produces a single, well-described commit on the dev branch |
| Merge gate bypass | Cherry-pick lands the commit directly, avoiding the pipeline-pass requirement that flaky tests would block |
| Audit trail | The closed MR links back to the review; the commit message can reference the MR number |

### Commit Message Format

Include the MR reference for traceability:

```
[TICKET] Description of change (MR !NNN, cherry-picked)
```

### When NOT to Use This

- **Release branches** — tests must pass; fix flaky tests or get exceptions through proper channels
- **Master/main** — production-ready code requires full merge gate compliance
- **When the feature branch has migration files** — migrations still follow normal rules (never cherry-pick migrations; create new ones if needed)

---

## Multi-Branch / Multi-Tier Development

For repositories with parallel release lines (e.g., nightly, release, master):

### Tier Strategy
```
nightly/development branch (least stable, most features)
    ↓ selective "Pick" via named branches
release/YYYY.MM branch (stabilization gate)
    ↓ selective "Pick" via named branches
master (production-ready)
```

**Key principles**:
- Features propagate **upward** through tiers via explicit picks, not automatic merges
- Not all nightly features move to release; not all release features move to master
- Each pick is a deliberate decision with its own branch and review

### Branch-Switching Safety
When switching between branches that have different dependencies:
- **Volume-mounted code** updates immediately (visible to Docker containers)
- **Pip-installed packages** inside Docker images do NOT update (stale until rebuild)
- **Migration numbering** can diverge between branches (same number, different content)

**Before working on a different branch**:
```bash
# If branches have different pip dependencies, rebuild
make build-satellites && make build-all

# Or: stay on one branch to avoid stale packages
```

**Symptoms of stale environment after branch switch**:
- `ModuleNotFoundError` for packages added on the other branch
- `INSTALLED_APPS` references apps not installed in the image
- Migration errors for migrations that don't exist in the current branch

---

## Migration Conflict Resolution

Django migrations are the highest-risk area of multi-branch git operations.

### When Conflicts Occur
After merging or rebasing, Django may detect multiple leaf nodes:
```
CommandError: Conflicting migrations detected; multiple leaf nodes:
(0335_create_system_role, 0335_merge_20251024_0411 in app)
```

### Resolution: Merge Migrations
```bash
# Create a merge migration that depends on BOTH conflicting migrations
make makemigrations-merge-server APP_NAME=<app_name>
# Result: 0336_merge_YYYYMMDD_HHMM.py with both 0335 variants as dependencies
```

### Critical Rules
- **ALWAYS** create merge migrations for conflicts
- **NEVER** rename or delete committed migrations (deployed environments already reference them)
- **NEVER** cherry-pick migration files from other branches (create new ones instead)
- **Test migrations** in all target environments (server, data, asset) before merging

### Post-Rebase Migration Hygiene
After rebasing a feature branch onto an updated base:
```bash
make makemigrations-server
# Django may suggest migrations for MANY apps
```

**Only accept migrations for apps YOU touched**. Delete all auto-suggested migrations for other apps - those should be created by the developers who made those changes.

---

## Merge Practices

### Merge vs Rebase
- **Feature branches → master**: Merge (preserves history, reviewable via MR)
- **Updating feature branch from base**: Either merge or rebase, but be consistent within a branch
- **After rebasing**: Check for auto-suggested migrations and clean up (see above)

### Avoiding Merge Pollution
Integration branches (e.g., cluster branches merging many features) can accumulate messy history:
- Self-merges: `Merge branch 'cluster' into 'cluster'` (a sign of fetch/merge loops)
- Repeated merges of the same branch

**Prevention**:
- Pull with rebase for integration branches: `git pull --rebase origin <branch>`
- Or use an explicit merge strategy and accept the history
